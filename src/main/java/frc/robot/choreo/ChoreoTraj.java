
package frc.robot.choreo;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import java.util.Map;
import java.util.OptionalInt;

// If these imports cause errors because you're not using ChoreoLib,
// turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
import choreo.auto.AutoRoutine;
import choreo.auto.AutoTrajectory;

/**
 * A class containing the name, start pose, end pose, and total time of every Choreo trajectory.
 * This prevents your code from referencing deleted or misspelled trajectories,
 * and removes the need for JSON parsing to load a trajectory's essential data.
 * DO NOT MODIFY THIS FILE YOURSELF! It is automatically generated by Choreo.
 */
public record ChoreoTraj(
    String name,
    OptionalInt segment,
    double totalTimeSecs,
    Pose2d initialPoseBlue,
    Pose2d endPoseBlue
) {
    public static final ChoreoTraj HumanPlayerToShootPositionThree = new ChoreoTraj(
	    "HumanPlayerToShootPositionThree",
	    OptionalInt.empty(),
	    1.20169,
	    new Pose2d(0.38, 0.671, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.64, 2.586, Rotation2d.fromRadians(0.658))
	);
	public static final ChoreoTraj PickupLeftToShootLeft = new ChoreoTraj(
	    "PickupLeftToShootLeft",
	    OptionalInt.empty(),
	    0.93811,
	    new Pose2d(0.9, 5.931, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.555, 5.305, Rotation2d.fromRadians(-0.549))
	);
	public static final ChoreoTraj PickupLeftToShootMiddle = new ChoreoTraj(
	    "PickupLeftToShootMiddle",
	    OptionalInt.empty(),
	    1.11782,
	    new Pose2d(0.9, 5.931, Rotation2d.fromRadians(3.142)),
	    new Pose2d(2.356, 4.033, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj PositionLeftToPickupLeft = new ChoreoTraj(
	    "PositionLeftToPickupLeft",
	    OptionalInt.empty(),
	    1.31823,
	    new Pose2d(3.893, 7.432, Rotation2d.fromRadians(0)),
	    new Pose2d(0.9, 5.931, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj PositionLeftToShoot = new ChoreoTraj(
	    "PositionLeftToShoot",
	    OptionalInt.empty(),
	    1.25655,
	    new Pose2d(3.55, 7.444, Rotation2d.fromRadians(0)),
	    new Pose2d(2.555, 5.305, Rotation2d.fromRadians(-0.549))
	);
	public static final ChoreoTraj PositionMiddleToPickup = new ChoreoTraj(
	    "PositionMiddleToPickup",
	    OptionalInt.empty(),
	    1.28411,
	    new Pose2d(3.442, 4.033, Rotation2d.fromRadians(0)),
	    new Pose2d(0.9, 5.931, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj PositionMiddleToShoot = new ChoreoTraj(
	    "PositionMiddleToShoot",
	    OptionalInt.empty(),
	    0.7849,
	    new Pose2d(3.658, 4.029, Rotation2d.fromRadians(1.565)),
	    new Pose2d(2.356, 4.033, Rotation2d.fromRadians(0))
	);
	public static final ChoreoTraj PositionRightToHumanPlayerPickup = new ChoreoTraj(
	    "PositionRightToHumanPlayerPickup",
	    OptionalInt.empty(),
	    1.24489,
	    new Pose2d(3.431, 0.659, Rotation2d.fromRadians(0)),
	    new Pose2d(0.38, 0.671, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj PositionRightToShoot = new ChoreoTraj(
	    "PositionRightToShoot",
	    OptionalInt.empty(),
	    1.21023,
	    new Pose2d(3.729, 0.555, Rotation2d.fromRadians(0)),
	    new Pose2d(2.64, 2.586, Rotation2d.fromRadians(0.658))
	);
	public static final ChoreoTraj ShootPositionOneToClimb = new ChoreoTraj(
	    "ShootPositionOneToClimb",
	    OptionalInt.empty(),
	    1.19602,
	    new Pose2d(2.555, 5.305, Rotation2d.fromRadians(-0.549)),
	    new Pose2d(1.147, 3.733, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj ShootPositionThreeToClimb = new ChoreoTraj(
	    "ShootPositionThreeToClimb",
	    OptionalInt.empty(),
	    0.96202,
	    new Pose2d(2.64, 2.586, Rotation2d.fromRadians(0.658)),
	    new Pose2d(1.071, 2.67, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj ShootPositionTwoToClimb = new ChoreoTraj(
	    "ShootPositionTwoToClimb",
	    OptionalInt.empty(),
	    0.85116,
	    new Pose2d(2.356, 4.033, Rotation2d.fromRadians(0)),
	    new Pose2d(1.146, 3.612, Rotation2d.fromRadians(3.142))
	);
	public static final ChoreoTraj TestPath = new ChoreoTraj(
	    "TestPath",
	    OptionalInt.empty(),
	    0.7981,
	    new Pose2d(4, 6, Rotation2d.fromRadians(3.142)),
	    new Pose2d(3, 5, Rotation2d.fromRadians(0))
	);

    /**
     * A map between trajectory names and their corresponding data.
     * This allows for trajectory data to be looked up with strings during runtime.
     */
    public static final Map<String, ChoreoTraj> ALL_TRAJECTORIES = Map.ofEntries(
    	Map.entry("HumanPlayerToShootPositionThree", HumanPlayerToShootPositionThree),
		Map.entry("PickupLeftToShootLeft", PickupLeftToShootLeft),
		Map.entry("PickupLeftToShootMiddle", PickupLeftToShootMiddle),
		Map.entry("PositionLeftToPickupLeft", PositionLeftToPickupLeft),
		Map.entry("PositionLeftToShoot", PositionLeftToShoot),
		Map.entry("PositionMiddleToPickup", PositionMiddleToPickup),
		Map.entry("PositionMiddleToShoot", PositionMiddleToShoot),
		Map.entry("PositionRightToHumanPlayerPickup", PositionRightToHumanPlayerPickup),
		Map.entry("PositionRightToShoot", PositionRightToShoot),
		Map.entry("ShootPositionOneToClimb", ShootPositionOneToClimb),
		Map.entry("ShootPositionThreeToClimb", ShootPositionThreeToClimb),
		Map.entry("ShootPositionTwoToClimb", ShootPositionTwoToClimb),
		Map.entry("TestPath", TestPath)
    );

    /**
     * Looks up the ChoreoTraj segment of the given overall ChoreoTraj.
     * WARNING: will raise an exception if not called with a valid segment index.
     */
    public ChoreoTraj segment(int segment) {
        var traj = ChoreoTraj.ALL_TRAJECTORIES.get(this.name + "$" + segment);
        if (traj == null) {
            throw new NullPointerException("Trajectory " + this.name + " does not have segment #" + segment + ".");
        }
        return traj;
    }
    
    // If these methods cause errors because you're not using ChoreoLib,
    // turn off "Include ChoreoLib-specific Helpers" in Choreo's codegen settings.
    /**
     * Load an AutoTrajectory directly from a ChoreoTraj, which may be a segment of a larger trajectory.
     */
    public AutoTrajectory asAutoTraj(AutoRoutine routine) {
        if (this.segment.isPresent()) {
            return routine.trajectory(this.name, this.segment.getAsInt());
        }
        return routine.trajectory(this.name);
    }
}
